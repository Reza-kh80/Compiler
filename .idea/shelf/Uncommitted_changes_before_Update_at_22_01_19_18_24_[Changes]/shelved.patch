Index: input.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>int main(){\r\nint a=3;\r\ndouble b = .5;\r\nif(b != 3){\r\nint p = \"fddf\" + \"dfdf\";\r\n}\r\nif(a == 1){\r\n\r\n}else{\r\n\r\n}\r\nint c=7;\r\nint d=a+c;\r\n\r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/input.txt b/input.txt
--- a/input.txt	(revision c3e8823cc1d5ffb1c0ad68b565a3930e72a5693a)
+++ b/input.txt	(date 1642603556528)
@@ -12,5 +12,14 @@
 int c=7;
 int d=a+c;
 
+int c = 0;
+c = 7;
+while(c <= 10) {
+    c += 1;
+    if(c != 9) {
+        c = c * (5 + 2) / 7 - (2 * 3) / c;
+    }
+}
+
 
 }
\ No newline at end of file
Index: src/Phase3.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import javax.swing.tree.DefaultMutableTreeNode;\r\nimport java.io.IOException;\r\nimport java.sql.Array;\r\nimport java.util.*;\r\n\r\nimport static java.util.Collections.singletonList;\r\nimport static java.util.Collections.sort;\r\n\r\n\r\npublic class Phase3 {\r\n\r\n    public static void main(String[] args) throws IOException, InterruptedException {\r\n\r\n        Phase2.main(null);\r\n\r\n\r\n        //import grammar:\r\n        Grammar.importGrammar();\r\n        Grammar.printGrammar();\r\n\r\n\r\n        LL1Table.createTable();\r\n        LL1Table.printTable();\r\n\r\n\r\n        parse();\r\n    }\r\n\r\n    private static void parse() {\r\n        Stack<String> stack = new Stack<>();\r\n        Stack<DefaultMutableTreeNode> nodeStack = new Stack<>();\r\n        stack.push(\"<program>\");\r\n        DefaultMutableTreeNode treeRoot = new DefaultMutableTreeNode(\"<program>\");\r\n        nodeStack.push(treeRoot);\r\n        List<String> tokens = Phase2.tokens;\r\n        System.out.println(\"Tokens: \" + tokens);\r\n\r\n        int i = 0;\r\n        while (i < tokens.size()) {\r\n            System.out.println(\"\\n\");\r\n            String stackTop = stack.lastElement();\r\n            String[] theToken = tokens.get(i).split(\":: \");\r\n            System.out.println(\"theToken: \" +theToken[1] + \" stackTop: \" + stackTop);\r\n            System.out.println(\"Stack: \" + stack);\r\n            if (stackTop.equals(theToken[1])) {\r\n                nodeStack.pop();\r\n                stack.pop();\r\n                i++;\r\n                continue;\r\n            } else if (!Grammar.allGrammars.containsKey(stackTop)) {\r\n                System.err.print(theToken[1] + \" The stack top does not match with the token\");\r\n                System.exit(1);\r\n            }\r\n            List<String>[] struct = LL1Table.getStructure(stackTop, theToken[1]);\r\n            if (struct == null) {\r\n                System.err.print(theToken[1] + \"  \" + stackTop + \" This cell in table is empty\");\r\n                System.exit(1);\r\n            } else {\r\n                List<String> theStruct = null;\r\n\r\n                if (struct.length == 1) {\r\n                    theStruct = struct[0];\r\n                }\r\n                else {\r\n\r\n                    if (stackTop.equals(\"<var declaration>\")) {\r\n                        boolean hasEqual = false;\r\n                        for (int j = i; j < tokens.size(); j++) {\r\n                            String t = tokens.get(j).split(\":: \")[1];\r\n\r\n                            if (t.equals(\"=\")) {\r\n                                hasEqual = true;\r\n                                break;\r\n                            } else if (t.equals(\";\"))\r\n                                break;\r\n                        }\r\n                        System.out.println(\"hasEqual : \" + hasEqual);\r\n                        String v = tokens.get(i + 1).split(\":: \")[1];\r\n                        System.out.println(\"variable: \" + v);\r\n                        for (List<String> str : struct) {\r\n                            if (v.equals(str.get(1))) {\r\n                                if (str.size() < 4 && !hasEqual) {\r\n                                    theStruct = str;\r\n                                    break;\r\n                                } else if (str.size() > 4 && hasEqual) {\r\n                                    theStruct = str;\r\n                                    break;\r\n                                }\r\n                            }\r\n                        }\r\n                    } else if (stackTop.equals(\"<if statement>\")) {\r\n                        for (int j = i+1; j < tokens.size(); j++) {\r\n                            String t = tokens.get(j).split(\":: \")[1];\r\n                            if (t.equals(\"if\")) {\r\n                                theStruct = struct[0];\r\n                                break;\r\n                            }\r\n                            else if (t.equals(\"else\")) {\r\n                                theStruct = struct[1];\r\n                                break;\r\n                            }\r\n                        }\r\n                        if (theStruct == null)\r\n                            theStruct = struct[0];\r\n\r\n                    }else if (stackTop.equals(\"<for statement>\")){\r\n                        String t = tokens.get(i+2).split(\":: \")[1];\r\n                        System.out.println(t);\r\n                        if (Tools.isVarType(t))\r\n                            theStruct = struct[1];\r\n                        else\r\n                            theStruct = struct[0];\r\n                    } else if(stackTop.equals(\"<assignment>\")) {\r\n                        String t = tokens.get(i + 1).split(\":: \")[1];\r\n                        System.out.println(t);\r\n                        if(t.equals(\"=\")) {\r\n                            theStruct = struct[0];\r\n                        } else if(t.equals(\"++\")) {\r\n                            theStruct = struct[1];\r\n                        } else if(t.equals(\"--\")) {\r\n                            theStruct = struct[2];\r\n                        } else {\r\n                            theStruct = struct[3];\r\n                        }\r\n                    }\r\n\r\n                }\r\n\r\n                stack.pop();\r\n                DefaultMutableTreeNode treeNode = nodeStack.pop();\r\n                System.out.println(theStruct);\r\n                if (!theStruct.contains(Grammar.EPSILON)) {\r\n                    ArrayList<DefaultMutableTreeNode> children = new ArrayList<>();\r\n                    for (int j = theStruct.size() - 1; j > -1; j--) {\r\n                        String st = theStruct.get(j);\r\n                        stack.push(st);\r\n                        DefaultMutableTreeNode d = new DefaultMutableTreeNode(st);\r\n                        nodeStack.push(d);\r\n                        children.add(0 , d);\r\n                    }\r\n                    for (DefaultMutableTreeNode child : children) {\r\n                        treeNode.add(child);\r\n                    }\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n        SwingDemo.showTree(treeRoot);\r\n    }\r\n}\r\n//pushing\r\n\r\nclass Grammar {\r\n    static final String EPSILON = \"É›\", ID = \"?ID?\", NUMBER = \"?NUMBER?\", STRING_LITERAL = \"?STRING?\";\r\n    static HashMap<String, List<String>[]> allGrammars = new HashMap<>();\r\n    String name;\r\n    List<String>[] structures;\r\n\r\n    @SafeVarargs\r\n    Grammar(String name, List<String>... structures) {\r\n        this.name = name;\r\n        this.structures = structures;\r\n        allGrammars.put(name, structures);\r\n    }\r\n\r\n    // function importgrammer\r\n    static void importGrammar() {\r\n        new Grammar(\"<program>\", Arrays.asList(\"int\", \"main\", \"(\", \")\", \"{\", \"<statements>\", \"}\"));\r\n\r\n        new Grammar(\"<if statement>\", Arrays.asList(\"if\", \"(\", \"<condition>\", \")\", \"{\", \"<statements>\", \"}\"),\r\n                Arrays.asList(\"if\", \"(\", \"<condition>\", \")\", \"{\", \"<statements>\", \"}\", \"else\", \"{\", \"<statements>\", \"}\"));\r\n\r\n        new Grammar(\"<for statement>\", Arrays.asList(\"for\", \"(\", \"<assignment>\", \"<condition>\", \";\", \"<assignment>\", \")\", \"{\", \"<statements>\", \"}\"),\r\n                Arrays.asList(\"for\", \"(\", \"<var declaration>\", \"<condition>\", \";\", \"<assignment>\", \")\", \"{\", \"<statements>\", \"}\"));\r\n\r\n        new Grammar(\"<while statement>\", Arrays.asList(\"while\", \"(\", \"<condition>\", \")\", \"{\", \"<statements>\", \"}\"));\r\n\r\n        new Grammar(\"<condition>\", Arrays.asList(\"<expression>\", \"<relational operator>\", \"<expression>\"));\r\n\r\n        new Grammar(\"<relational operator>\", singletonList(\"<\"), singletonList(\">\"), singletonList(\"<=\"),\r\n                singletonList(\">=\"), singletonList(\"==\") , singletonList(\"!=\"));\r\n\r\n        createGrammar(\"<var declaration>\",\r\n                Arrays.asList(\"<var_type>\",\r\n                        ID, \";\"), Arrays.asList(\"<var_type>\", ID, \"=\", \"<expression>\", \";\"));\r\n\r\n        new Grammar(\"<expression>\", Arrays.asList(\"<term>\", \"<expression'>\"));\r\n\r\n        new Grammar(\"<expression'>\", Arrays.asList(\"+\", \"<term>\", \"<expression'>\"),\r\n                Arrays.asList(\"-\", \"<term>\", \"<expression'>\"), singletonList(EPSILON));\r\n\r\n        new Grammar(\"<term>\", Arrays.asList(\"<factor>\", \"<term'>\"));\r\n\r\n        new Grammar(\"<term'>\", Arrays.asList(\"*\", \"<factor>\", \"<term'>\"),\r\n                Arrays.asList(\"/\", \"<factor>\", \"<term'>\"), singletonList(EPSILON));\r\n\r\n\r\n        List<String>[] struct = new List[Phase2.identifiers.size() + Phase2.numbers.size() + 1 + Phase2.stringLiterals.size()];\r\n        int index = 0;\r\n        for (int i = 0; i < Phase2.identifiers.size(); i++) {\r\n            struct[index++] = singletonList(Phase2.identifiers.get(i));\r\n        }\r\n        for (int i = 0; i < Phase2.numbers.size(); i++) {\r\n            struct[index++] = singletonList(Phase2.numbers.get(i));\r\n        }\r\n        for (int i = 0; i < Phase2.stringLiterals.size(); i++) {\r\n            struct[index++] = singletonList(Phase2.stringLiterals.get(i));\r\n        }\r\n        struct[index] = Arrays.asList(\"(\", \"<expression>\", \")\");\r\n        new Grammar(\"<factor>\", struct);\r\n\r\n        new Grammar(\"<statements>\", Arrays.asList(\"<statement>\", \"<statements>\"));\r\n\r\n        new Grammar(\"<statement>\", singletonList(\"<assignment>\"), singletonList(\"<var declaration>\"),\r\n                singletonList(\"<if statement>\"), singletonList(\"<for statement>\"), singletonList(\"<while statement>\"));\r\n\r\n        createGrammar(\"<assignment>\", Arrays.asList(ID, \"=\", \"<expression>\", \";\"), Arrays.asList(ID, \"++\", \";\"),\r\n                Arrays.asList(ID, \"--\", \";\"), Arrays.asList(ID, \"<opt>\", \"=\", \"<expression>\", \";\"));\r\n\r\n        new Grammar(\"<opt>\", singletonList(\"+\"), singletonList(\"-\"), singletonList(\"/\"), singletonList(\"*\"));\r\n\r\n\r\n        List<String> varTypes = new ArrayList<>(Tools.getVarTypes());\r\n        List<String>[] varTypeLists = new List[varTypes.size()];\r\n\r\n        for (int i = 0; i < varTypeLists.length; i++) {\r\n            varTypeLists[i] = singletonList(varTypes.get(i));\r\n        }\r\n        new Grammar(\"<var_type>\", varTypeLists);\r\n\r\n\r\n    }\r\n\r\n\r\n    private static void createGrammar(String grammarName, List<String>... textHolders) {\r\n        List<String>[] struct = new List[textHolders.length * Phase2.identifiers.size()];\r\n        int index = 0;\r\n        for (List<String> rule : textHolders) {\r\n            for (String none : Phase2.identifiers) {\r\n                List<String> idRule = new ArrayList<>();\r\n                for (String part : rule) {\r\n                    if (part.equals(ID))\r\n                        idRule.add(none);\r\n                    else\r\n                        idRule.add(part);\r\n                }\r\n                struct[index++] = idRule;\r\n            }\r\n        }\r\n\r\n        new Grammar(grammarName, struct);\r\n    }\r\n\r\n    static void printGrammar() {\r\n        System.out.println(\"\\t\\t\" + \"GRAMMAR\");\r\n        Set<String> keys = allGrammars.keySet();\r\n        for (String key : keys) {\r\n            System.out.print(key + \" : \");\r\n            List<String>[] structure = allGrammars.get(key);\r\n            for (List<String> list : structure) {\r\n                System.out.print(list + \" , \");\r\n            }\r\n            System.out.println();\r\n        }\r\n        System.out.println(\"\\t\\t\" + \"---------\");\r\n    }\r\n}\r\n\r\nclass LL1Table {\r\n    static HashMap<String, Map<String, List<String>[]>> table = new HashMap<>();\r\n\r\n    static void createTable() {\r\n        HashMap<String, List<String>[]> allGrammars = Grammar.allGrammars;\r\n        table.put(\"<program>\", Map.of(\"int\", allGrammars.get(\"<program>\")));\r\n        table.put(\"<if statement>\", Map.of(\"if\", allGrammars.get(\"<if statement>\")));\r\n        table.put(\"<for statement>\", Map.of(\"for\", allGrammars.get(\"<for statement>\")));\r\n        table.put(\"<while statement>\", Map.of(\"while\", allGrammars.get(\"<while statement>\")));\r\n\r\n        //\"<condition>\"\r\n        List<String>[] conditionStructure = allGrammars.get(\"<condition>\");\r\n        Map<String, List<String>[]> tRow = new HashMap<>();\r\n        tRow.put(\"(\", conditionStructure);\r\n        for (String id : Phase2.identifiers) {\r\n            tRow.put(id, conditionStructure);\r\n        }\r\n        for (String number : Phase2.numbers) {\r\n            tRow.put(number, conditionStructure);\r\n        }\r\n        for (String literal : Phase2.stringLiterals) {\r\n            tRow.put(literal, conditionStructure);\r\n        }\r\n        table.put(\"<condition>\", tRow);\r\n        tRow = new HashMap<>();\r\n        //....................\r\n\r\n\r\n        //<relational operator>\r\n        List<String>[] relationOperators = allGrammars.get(\"<relational operator>\");\r\n        for (List<String> list : relationOperators) {\r\n            List[] lists = new List[1];\r\n            lists[0] = singletonList(list.get(0));\r\n            tRow.put(list.get(0), lists);\r\n        }\r\n        table.put(\"<relational operator>\", tRow);\r\n        tRow = new HashMap<>();\r\n\r\n        //<var declration>\r\n        List<String>[] varTypeStructure = allGrammars.get(\"<var declaration>\");\r\n        for (String varType : Tools.getVarTypes()) {\r\n            tRow.put(varType, varTypeStructure);\r\n        }\r\n        table.put(\"<var declaration>\", tRow);\r\n        tRow = new HashMap<>();\r\n        //....................\r\n\r\n        //<expression>\r\n        List<String>[] expStructure = allGrammars.get(\"<expression>\");\r\n        tRow.put(\"(\", expStructure);\r\n        for (String id : Phase2.identifiers) {\r\n            tRow.put(id, expStructure);\r\n        }\r\n        for (String num : Phase2.numbers) {\r\n            tRow.put(num, expStructure);\r\n        }\r\n        for (String str : Phase2.stringLiterals) {\r\n            tRow.put(str, expStructure);\r\n        }\r\n        table.put(\"<expression>\", tRow);\r\n        tRow = new HashMap<>();\r\n        //...................\r\n\r\n        //<expression'>\r\n        List<String>[] expPrimStructure = allGrammars.get(\"<expression'>\");\r\n        List<String>[] epsilon = new List[1];\r\n        epsilon[0] = Arrays.asList(Grammar.EPSILON);\r\n        String arr[] = {\">=\", \"<=\", \">\", \"<\", \"==\",\"!=\", \";\", \")\"};\r\n        for (String op : arr) {\r\n            tRow.put(op, epsilon);\r\n        }\r\n        String arr2[] = {\"+\", \"-\"};\r\n        for (String op1 : arr2) {\r\n            if (op1.equals(\"+\")) {\r\n                List[] listPlus = new List[1];\r\n                listPlus[0] = expPrimStructure[0];\r\n                tRow.put(op1, listPlus);\r\n            } else {\r\n                List[] listMinus = new List[1];\r\n                listMinus[0] = expPrimStructure[1];\r\n                tRow.put(op1, listMinus);\r\n            }\r\n        }\r\n        table.put(\"<expression'>\", tRow);\r\n        tRow = new HashMap<>();\r\n        //.................\r\n\r\n        //<term>\r\n        List<String>[] termStructure = allGrammars.get(\"<term>\");\r\n        tRow.put(\"(\", termStructure);\r\n        for (String id : Phase2.identifiers) {\r\n            tRow.put(id, termStructure);\r\n        }\r\n        for (String num : Phase2.numbers) {\r\n            tRow.put(num, termStructure);\r\n        }\r\n        for (String str : Phase2.stringLiterals) {\r\n            tRow.put(str, termStructure);\r\n        }\r\n        table.put(\"<term>\", tRow);\r\n        tRow = new HashMap<>();\r\n        //....................\r\n\r\n        //<term'>\r\n        List<String>[] termPrimStructure = allGrammars.get(\"<term'>\");\r\n        String arr3[] = {\">=\", \"<=\", \">\", \"<\", \"==\",\"!=\", \"+\", \"-\", \";\", \"(\" , \")\"};\r\n        for (String op : arr3) {\r\n            tRow.put(op, epsilon);\r\n        }\r\n        String arr4[] = {\"*\", \"/\"};\r\n        for (String op1 : arr4) {\r\n            if (op1.equals(\"*\")) {\r\n                List[] listMult = new List[1];\r\n                listMult[0] = singletonList(termPrimStructure[0]);\r\n                tRow.put(op1, listMult);\r\n            } else {\r\n                List[] listDivide = new List[1];\r\n                listDivide[0] = singletonList(termPrimStructure[1]);\r\n                tRow.put(op1, listDivide);\r\n            }\r\n        }\r\n        table.put(\"<term'>\", tRow);\r\n        tRow = new HashMap<>();\r\n        //..................\r\n\r\n        //<factor>\r\n        List<String>[] factorStructure = allGrammars.get(\"<factor>\");\r\n        List<String>[] list = new List[1];\r\n        list[0] = factorStructure[factorStructure.length - 1];\r\n        tRow.put(\"(\", list);\r\n        ArrayList<String> total = new ArrayList<>();\r\n        total.addAll(Phase2.identifiers);\r\n        total.addAll(Phase2.numbers);\r\n        total.addAll(Phase2.stringLiterals);\r\n\r\n        for (String check : total) {\r\n            List<String>[] FS = new List[1];\r\n            FS[0] = Arrays.asList(check);\r\n            tRow.put(check, FS);\r\n        }\r\n\r\n        table.put(\"<factor>\", tRow);\r\n        tRow = new HashMap<>();\r\n        //................\r\n\r\n        //<statement>\r\n        List<String>[] stateStructure = allGrammars.get(\"<statement>\");\r\n        for (String vartype : Tools.getVarTypes()) {\r\n            List[] vartp = new List[1];\r\n            vartp[0] = stateStructure[1];\r\n            tRow.put(vartype, vartp);\r\n        }\r\n        for (String id : Phase2.identifiers) {\r\n            List[] iden = new List[1];\r\n            iden[0] = stateStructure[0];\r\n            tRow.put(id, iden);\r\n        }\r\n        String arr5[] = {\"if\", \"for\", \"while\"};\r\n        for (String op : arr5) {\r\n            if (op.equals(\"if\")) {\r\n                List[] listIf = new List[1];\r\n                listIf[0] = stateStructure[2];\r\n                tRow.put(op, listIf);\r\n            } else if (op.equals(\"for\")) {\r\n                List[] listIf = new List[1];\r\n                listIf[0] = stateStructure[3];\r\n                tRow.put(op, listIf);\r\n            } else {\r\n                List[] listWhile = new List[1];\r\n                listWhile[0] = stateStructure[4];\r\n                tRow.put(op, listWhile);\r\n            }\r\n        }\r\n        table.put(\"<statement>\", tRow);\r\n        tRow = new HashMap<>();\r\n        //........................................\r\n\r\n        //<statements>\r\n        List<String>[] statesStructure = allGrammars.get(\"<statements>\");\r\n        tRow.put(\"}\" , epsilon);\r\n        for (String varType : Tools.getVarTypes()) {\r\n            tRow.put(varType, statesStructure);\r\n        }\r\n        for (String id : Phase2.identifiers) {\r\n            tRow.put(id, statesStructure);\r\n        }\r\n        String arr6[] = {\"if\", \"for\", \"while\"};\r\n        for (String op : arr6) {\r\n            if (op.equals(\"if\")) {\r\n                tRow.put(op, statesStructure);\r\n            } else if (op.equals(\"for\")) {\r\n                tRow.put(op, statesStructure);\r\n            } else {\r\n                tRow.put(op, statesStructure);\r\n            }\r\n        }\r\n        table.put(\"<statements>\", tRow);\r\n        tRow = new HashMap<>();\r\n        //........................................\r\n\r\n        //<opt>\r\n        List<String>[] optStructure = allGrammars.get(\"<opt>\");\r\n        String arr7[] = {\"+\", \"-\", \"*\", \"/\"};\r\n        for (String op : arr7) {\r\n            if (op.equals(\"*\")) {\r\n                List[] _M_ = new List[1];\r\n                _M_[0] = optStructure[3];\r\n                tRow.put(op, _M_);\r\n            } else if (op.equals(\"/\")) {\r\n                List[] _D_ = new List[1];\r\n                _D_[0] = optStructure[2];\r\n                tRow.put(op, _D_);\r\n            } else if (op.equals(\"+\")) {\r\n                List[] _P_ = new List[1];\r\n                _P_[0] = optStructure[0];\r\n                tRow.put(op, _P_);\r\n            } else {\r\n                List[] _MM_ = new List[1];\r\n                _MM_[0] = optStructure[1];\r\n                tRow.put(op, _MM_);\r\n            }\r\n        }\r\n        table.put(\"<opt>\", tRow);\r\n        tRow = new HashMap<>();\r\n\r\n        //..............................\r\n\r\n        //<var_type>\r\n        List<String>[] vartypeStructure = allGrammars.get(\"<var_type>\");\r\n        int i = 0;\r\n        for (String vartype : Tools.getVarTypes()) {\r\n            List[] Type = new List[1];\r\n            Type[0] = vartypeStructure[i];\r\n            tRow.put(vartype, Type);\r\n            i++;\r\n        }\r\n        table.put(\"<var_type>\", tRow);\r\n        tRow = new HashMap<>();\r\n\r\n        //...................\r\n\r\n        for (String id : Phase2.identifiers) {\r\n            List<String>[] list2 = new List[]{Arrays.asList(id, \"=\", \"<expression>\", \";\"), Arrays.asList(id, \"++\", \";\"),\r\n                    Arrays.asList(id, \"--\", \";\"), Arrays.asList(id, \"<opt>\", \"=\", \"<expression>\", \";\")};\r\n            tRow.put(id, list2);\r\n\r\n        }\r\n        table.put(\"<assignment>\", tRow);\r\n        tRow = new HashMap<>();\r\n    }\r\n\r\n    static void printTable() {\r\n        ArrayList<String> terminals = new ArrayList<>(Grammar.allGrammars.keySet());\r\n        for (String terminal : terminals) {\r\n            Map<String, List<String>[]> map = table.get(terminal);\r\n            if (map == null)\r\n                continue;\r\n            System.out.println(terminal + \"  : \");\r\n            for (String key :\r\n                    map.keySet()) {\r\n                List<String>[] lists = map.get(key);\r\n                System.out.print(key + \" : \");\r\n                for (List<String> list : lists) {\r\n                    System.out.println(list);\r\n                }\r\n\r\n            }\r\n            System.out.println();\r\n        }\r\n    }\r\n\r\n\r\n    static List<String>[] getStructure(String nonTerminal, String terminal) {\r\n        return table.get(nonTerminal).get(terminal);\r\n    }\r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/Phase3.java b/src/Phase3.java
--- a/src/Phase3.java	(revision c3e8823cc1d5ffb1c0ad68b565a3930e72a5693a)
+++ b/src/Phase3.java	(date 1642603730174)
@@ -220,7 +220,7 @@
         createGrammar("<assignment>", Arrays.asList(ID, "=", "<expression>", ";"), Arrays.asList(ID, "++", ";"),
                 Arrays.asList(ID, "--", ";"), Arrays.asList(ID, "<opt>", "=", "<expression>", ";"));
 
-        new Grammar("<opt>", singletonList("+"), singletonList("-"), singletonList("/"), singletonList("*"));
+        new Grammar("<opt>", singletonList("+="), singletonList("-="), singletonList("/="), singletonList("*="));
 
 
         List<String> varTypes = new ArrayList<>(Tools.getVarTypes());
@@ -471,17 +471,17 @@
 
         //<opt>
         List<String>[] optStructure = allGrammars.get("<opt>");
-        String arr7[] = {"+", "-", "*", "/"};
+        String arr7[] = {"+=", "-=", "*=", "/="};
         for (String op : arr7) {
-            if (op.equals("*")) {
+            if (op.equals("*=")) {
                 List[] _M_ = new List[1];
                 _M_[0] = optStructure[3];
                 tRow.put(op, _M_);
-            } else if (op.equals("/")) {
+            } else if (op.equals("/=")) {
                 List[] _D_ = new List[1];
                 _D_[0] = optStructure[2];
                 tRow.put(op, _D_);
-            } else if (op.equals("+")) {
+            } else if (op.equals("+=")) {
                 List[] _P_ = new List[1];
                 _P_[0] = optStructure[0];
                 tRow.put(op, _P_);
